import { FirebaseOperations } from '@core/services/firebase/firebase-api/firebaseOperations.interface';
import {
	AngularFirestore,
	AngularFirestoreCollection,
	QuerySnapshot
} from '@angular/fire/compat/firestore';
import { map, Observable, take } from 'rxjs';
import { AngularFirestoreDocument } from '@angular/fire/compat/firestore/document/document';
import {
	Action,
	DocumentChangeAction,
	DocumentSnapshot
} from '@angular/fire/compat/firestore/interfaces';
import firebase from 'firebase/compat';
import WhereFilterOp = firebase.firestore.WhereFilterOp;

/**
 * Main service to interaction with firebase, implement all methods needed to create, update, remove documents,
 * adding collection, sub collection, query documents in collection
 *
 * Generic Types ->
 * T - Type of entity (interface | class) that have documents stored in collection: IUser, IRole, ICategory
 * ID - Type of unique identifier, that use for indexing documents : string | number
 * S - Type entity of child / sub collection if exists: ISubCategory
 * N - Type entity to query across all collection
 */
export abstract class FirebaseCrudService<T, ID, S>
	implements FirebaseOperations<T, ID, S>
{
	protected constructor(
		protected base: string,
		protected sub: string,
		protected firebase: AngularFirestore
	) {}

	/**
	 * Get document by id from collection.
	 * Returns an observable of document data
	 * @param id document id
	 */
	getDoc(id: ID): Observable<T | undefined> {
		const docReference: AngularFirestoreDocument<T> = this.firebase.doc<T>(
			`${this.base}/${id}`
		);
		return docReference.valueChanges({ idField: 'id' });
	}

	/**
	 * Create a document in a collection, with passed id
	 * @param id document identifier
	 * @param content document data to write
	 */
	addDoc(id: ID, content: T): Promise<void> {
		const collectionReference: AngularFirestoreCollection<T> =
			this.firebase.collection<T>(`${this.base}`);
		return collectionReference.doc(`${id}`).set(content);
	}

	/**
	 * Create a document in a collection, with id generated by Firestore, guarantee of unique
	 * @param content document data to write
	 */
	addDocWithAutoId(content: T): Promise<string> {
		// We can return that id needed
		const id = this.firebase.createId();
		const docReference: AngularFirestoreDocument<T> = this.firebase.doc<T>(
			`${this.base}/${id}`
		);
		return docReference.set(content).then(result => Promise.resolve(id));
	}

	/**
	 * Partially update document in a collection by document id. Allow update,
	 * only one field for example
	 * @param id document identifier
	 * @param content partial object data to write
	 */
	updateDoc(id: ID, content: Partial<T>): Promise<void> {
		const docReference: AngularFirestoreDocument<T> = this.firebase.doc<T>(
			`${this.base}/${id}`
		);
		return docReference.update(content);
	}

	/**
	 * Delete document from collection by id of document
	 * @param id document identifier
	 */
	deleteDoc(id: ID): Promise<void> {
		const docReference: AngularFirestoreDocument<T> = this.firebase.doc<T>(
			`${this.base}/${id}`
		);
		return docReference.delete();
	}

	deleteDocFromSubCollection(
		parentDocumentId: ID,
		subCollectionDocumentId: ID
	): Promise<void> {
		const docReference: AngularFirestoreDocument<T> = this.firebase
			.collection<T>(`${this.base}`)
			.doc<T>(`${parentDocumentId}`);
		const collectionReference: AngularFirestoreCollection<S> =
			docReference.collection(this.sub);

		return collectionReference.doc(`${subCollectionDocumentId}`).delete();
	}

	/**
	 * Return an observable of document, from sub collection of parent document
	 * @param parentDocumentId id of document in parent/main collection
	 * @param subCollectionDocumentId id of document in sub collection
	 */
	getDocFromSubCollection(
		parentDocumentId: ID,
		subCollectionDocumentId: ID
	): Observable<S> {
		const docReference: AngularFirestoreDocument<T> = this.firebase
			.collection<T>(`${this.base}`)
			.doc<T>(`${parentDocumentId}`);
		const collectionReference: AngularFirestoreCollection<S> =
			docReference.collection(this.sub);

		return collectionReference.doc(`${subCollectionDocumentId}`).valueChanges();
	}

	/**
	 * Return sub collection of document by parent id
	 * @param id Identifier of parent document
	 */
	getSubCollection(id: ID): Observable<S[]> {
		const docReference: AngularFirestoreDocument<T> = this.firebase
			.collection<T>(`${this.base}`)
			.doc<T>(`${id}`);
		return docReference.collection<S>(this.sub).valueChanges({ idField: 'id' });
	}

	/**
	 * Add a document with autoId in sub collection of parent document, fetched by id
	 * @param id parent document identifier
	 * @param content object to write
	 */
	addDocToSubCollection(id: ID, content: any): Promise<void> {
		const docReference: AngularFirestoreDocument<T> = this.firebase
			.collection<T>(`${this.base}`)
			.doc<T>(`${id}`);
		return docReference
			.collection(this.sub)
			.add(content)
			.then(document => {
				console.log('Document in sub collection was added');
			});
	}

	/**
	 * Add a document with autoId in sub collection of parent document, fetched by id
	 * @param id parent document identifier
	 * @param content object to write
	 */
	addDocToSubCollectionWithCustomId(
		parentId: ID,
		childId: ID,
		content: any
	): Promise<void> {
		const docReference: AngularFirestoreDocument<T> = this.firebase
			.collection<T>(`${this.base}`)
			.doc<T>(`${parentId}`);
		return docReference
			.collection(this.sub)
			.doc(`${childId}`)
			.set(content)
			.then(document => {
				console.log('Document in sub collection was added');
			});
	}

	/**
	 * Return current collection data, without metadata, trigger new values, when
	 * some documents from collection will be removed or added. Attach id of document,
	 * to each returned object in 'id' field.
	 */
	getCollection(): Observable<T[]> {
		const collectionReference: AngularFirestoreCollection<T> =
			this.firebase.collection<T>(this.base);
		return collectionReference.valueChanges({ idField: 'id' });
	}

	/**
	 * Return current collection data snapshot. Don't return live updates, only
	 * return actual data in a time of call and immediately unsubscribe. Attach id of document,
	 * to each returned object in 'id' field.
	 */
	getCollectionSnapshot(): Observable<T[]> {
		const collectionReference: AngularFirestoreCollection<T> =
			this.firebase.collection<T>(this.base);
		return collectionReference.valueChanges({ idField: 'id' }).pipe(take(1));
	}

	/**
	 * Similar to getCollectionSnapshot(), but return live updates, and append for
	 * each document his id, that allow to us query sub documents, or change existed
	 */
	getCollectionWithIds(): Observable<T[]> {
		const collectionReference: AngularFirestoreCollection<T> =
			this.firebase.collection<T>(this.base);
		return collectionReference.snapshotChanges().pipe(
			map(documents => {
				return documents.map(doc => {
					const data = doc.payload.doc.data();
					const id = doc.payload.doc.id;
					return { id, ...data };
				});
			})
		);
	}

	/**
	 * Return document data observable, that will be emitted only one time,
	 * and immediately unsubscribe. To access data in your service, simple subscribe to it
	 * @param id
	 */
	getDocSnapshot(id: ID): Observable<T> {
		const docReference: AngularFirestoreDocument<T> = this.firebase.doc<T>(
			`${this.base}/${id}`
		);
		return docReference.valueChanges().pipe(take(1));
	}

	/**
	 * Returns an Observable of data as a DocumentChangeAction. Use it, when
	 * you need your document data, but also want a metadata, that allow to you
	 * retrieve document ref, id, data, etc. Return an action performed on
	 * document (added, removed, updated), ideally fit, it you want to handle
	 * that action, and react on that, and changes itself.
	 * @param id
	 */
	getDocSnapshotChanges(id: ID): Observable<Action<DocumentSnapshot<T>>> {
		const docReference: AngularFirestoreDocument<T> = this.firebase.doc<T>(
			`${this.base}/${id}`
		);

		return docReference.snapshotChanges();
	}

	/**
	 * Returns an Observable of the most recent changes as a DocumentChangeAction[].
	 * Emits changes as they occur, allow to listen some specific actions,
	 * stateChanges(['added']) - only adding documents for example
	 */
	getCollectionStateChanges(): Observable<DocumentChangeAction<T>[]> {
		return this.firebase.collection<T>(this.base).stateChanges();
	}

	/**
	 * Return result of query inside collection. Allow search only in parent collection
	 * Allow find documents in collection by some conditions.
	 * Form example, find all users, where roleId = 3;
	 * - getDocumentsWhere('roleId', '==', 3);
	 * @param fieldName name of document field
	 * @param operationStr '=', '==', '!=', '>=', '>', 'array-contains', 'in', 'array-contains-any', and 'not-in'.
	 * @param value comparing value
	 */
	getDocumentsWhere(
		fieldName: string,
		operationStr: WhereFilterOp = '==',
		value: any
	): Observable<QuerySnapshot<T>> {
		const collectionQueryResult: AngularFirestoreCollection<T> =
			this.firebase.collection<T>(this.base, ref =>
				ref.where(fieldName, operationStr, value)
			);
		return collectionQueryResult.get();
	}

	/**
	 * Do the same as getDocumentsWhere() method, but return a Promise instead Observable
	 * @param fieldName
	 * @param operationStr
	 * @param value
	 */
	async getDocumentsWherePromise(
		fieldName: string,
		operationStr: WhereFilterOp = '==',
		value: any
	): Promise<QuerySnapshot<T>> {
		const collectionQueryResult: AngularFirestoreCollection<T> =
			this.firebase.collection<T>(this.base, ref =>
				ref.where(fieldName, operationStr, value)
			);
		return await collectionQueryResult.ref.get().then(response => response);
	}

	/**
	 * Allow query on any collection in DB, any level of nesting
	 * @param collectionName name of interested collection
	 * @param fieldName document field
	 * @param operationStr operation '==' | '>=' | 'array-contains'
	 * @param value comparing value
	 * @param entityType type of returned model
	 */
	getNestedCollectionWhere<N>(
		collectionName: string,
		fieldName: string,
		operationStr: WhereFilterOp,
		value: any,
		entityType: N
	): Observable<N[]> {
		const collectionQueryResult: AngularFirestoreCollection<N> =
			this.firebase.collection<N>(this.base, ref =>
				ref.where(fieldName, operationStr, value)
			);
		return collectionQueryResult.valueChanges();
	}
}
